<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ADHARA ‚Äî Advanced Mouse Tracker v2</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', system-ui, sans-serif;
            background: linear-gradient(135deg, #0f172a 0%, #1e1b4b 100%);
            min-height: 100vh;
            color: #f1f5f9;
            padding: 16px;
        }

        .container {
            max-width: 1600px;
            margin: 0 auto;
        }

        header {
            text-align: center;
            margin-bottom: 20px;
        }

        h1 {
            font-size: 1.8rem;
            background: linear-gradient(90deg, #06b6d4, #8b5cf6, #ec4899);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
        }

        .subtitle {
            color: #94a3b8;
            font-size: 0.9rem;
            margin-top: 4px;
        }

        .main-grid {
            display: grid;
            grid-template-columns: 400px 1fr;
            gap: 16px;
        }

        .card {
            background: rgba(15, 23, 42, 0.9);
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: 12px;
            padding: 16px;
        }

        .card-title {
            font-size: 0.95rem;
            font-weight: 600;
            margin-bottom: 12px;
            color: #94a3b8;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        /* Tracking Canvas */
        .tracking-canvas-container {
            position: relative;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
        }

        #trackingCanvas {
            width: 100%;
            height: 350px;
            cursor: crosshair;
        }

        .canvas-overlay {
            position: absolute;
            top: 8px;
            left: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            font-family: monospace;
        }

        .canvas-fps {
            position: absolute;
            top: 8px;
            right: 8px;
            background: rgba(0, 0, 0, 0.7);
            padding: 6px 10px;
            border-radius: 4px;
            font-size: 0.75rem;
            color: #10b981;
        }

        /* Metrics */
        .metrics-grid {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 8px;
            margin-bottom: 12px;
        }

        .metric {
            background: rgba(30, 41, 59, 0.8);
            border-radius: 8px;
            padding: 12px;
            text-align: center;
        }

        .metric-value {
            font-size: 1.4rem;
            font-weight: 700;
            font-family: monospace;
        }

        .metric-label {
            font-size: 0.7rem;
            color: #64748b;
            margin-top: 2px;
        }

        .metric-value.low {
            color: #10b981;
        }

        .metric-value.medium {
            color: #f59e0b;
        }

        .metric-value.high {
            color: #ef4444;
        }

        /* Charts */
        .charts-grid {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 12px;
        }

        .chart-container {
            height: 180px;
        }

        /* Controls */
        .controls {
            display: flex;
            gap: 8px;
            margin-top: 12px;
        }

        .btn {
            flex: 1;
            padding: 10px;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            border: none;
            font-size: 0.85rem;
        }

        .btn-start {
            background: linear-gradient(135deg, #10b981, #059669);
            color: white;
        }

        .btn-stop {
            background: linear-gradient(135deg, #ef4444, #dc2626);
            color: white;
        }

        .btn-reset {
            background: rgba(71, 85, 105, 0.6);
            color: #e2e8f0;
        }

        .btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        /* Raw Data Panel */
        .raw-data {
            background: #000;
            border-radius: 6px;
            padding: 8px;
            font-family: monospace;
            font-size: 0.7rem;
            max-height: 150px;
            overflow-y: auto;
            color: #10b981;
        }

        /* Friction Badge */
        .friction-display {
            text-align: center;
            padding: 16px;
            border-radius: 8px;
            margin-bottom: 12px;
        }

        .friction-display.low {
            background: rgba(16, 185, 129, 0.2);
            border: 2px solid #10b981;
        }

        .friction-display.medium {
            background: rgba(245, 158, 11, 0.2);
            border: 2px solid #f59e0b;
        }

        .friction-display.high {
            background: rgba(239, 68, 68, 0.2);
            border: 2px solid #ef4444;
        }

        .friction-level {
            font-size: 2rem;
            font-weight: 800;
        }

        .friction-label {
            font-size: 0.8rem;
            color: #94a3b8;
        }

        /* Advanced Metrics */
        .advanced-metrics {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 8px;
            font-size: 0.75rem;
        }

        .adv-metric {
            display: flex;
            justify-content: space-between;
            padding: 6px 8px;
            background: rgba(30, 41, 59, 0.5);
            border-radius: 4px;
        }

        .adv-metric-label {
            color: #64748b;
        }

        .adv-metric-value {
            font-weight: 600;
            font-family: monospace;
        }

        /* Signal Quality */
        .signal-bar {
            height: 4px;
            background: #1e293b;
            border-radius: 2px;
            margin-top: 8px;
            overflow: hidden;
        }

        .signal-fill {
            height: 100%;
            background: linear-gradient(90deg, #10b981, #06b6d4);
            transition: width 0.3s;
        }

        /* AI Summary Panel */
        .ai-panel {
            margin-top: 16px;
            border: 2px solid #8b5cf6;
            background: linear-gradient(135deg, rgba(139, 92, 246, 0.1), rgba(236, 72, 153, 0.1));
        }

        .ai-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .ai-status {
            display: flex;
            align-items: center;
            gap: 6px;
            font-size: 0.75rem;
            color: #94a3b8;
        }

        .ai-status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #64748b;
        }

        .ai-status-dot.connected {
            background: #10b981;
        }

        .ai-status-dot.thinking {
            background: #f59e0b;
            animation: pulse 1s infinite;
        }

        .ai-status-dot.error {
            background: #ef4444;
        }

        .ai-summary {
            background: rgba(0, 0, 0, 0.4);
            border-radius: 8px;
            padding: 12px;
            min-height: 100px;
            max-height: 200px;
            overflow-y: auto;
            font-size: 0.85rem;
            line-height: 1.6;
            color: #e2e8f0;
        }

        .ai-summary.loading {
            color: #94a3b8;
            font-style: italic;
        }

        .ai-verdict {
            margin-top: 12px;
            padding: 10px;
            border-radius: 6px;
            font-weight: 600;
            text-align: center;
        }

        .ai-verdict.normal {
            background: rgba(16, 185, 129, 0.2);
            border: 1px solid #10b981;
            color: #34d399;
        }

        .ai-verdict.uncertain {
            background: rgba(245, 158, 11, 0.2);
            border: 1px solid #f59e0b;
            color: #fbbf24;
        }

        .ai-verdict.abnormal {
            background: rgba(239, 68, 68, 0.2);
            border: 1px solid #ef4444;
            color: #f87171;
        }

        .model-select {
            background: rgba(30, 41, 59, 0.8);
            border: 1px solid rgba(71, 85, 105, 0.5);
            border-radius: 4px;
            padding: 4px 8px;
            color: #e2e8f0;
            font-size: 0.75rem;
        }
    </style>
</head>

<body>
    <div class="container">
        <header>
            <h1>üî¨ ADHARA Advanced Mouse Tracker v2</h1>
            <p class="subtitle">High-precision micro-tremor and behavioral pattern detection (60 FPS sampling)</p>
        </header>

        <div class="main-grid">
            <!-- Left Panel: Tracking Area -->
            <div>
                <div class="card">
                    <div class="card-title">üìç Tracking Area</div>
                    <div class="tracking-canvas-container">
                        <canvas id="trackingCanvas" width="368" height="350"></canvas>
                        <div class="canvas-overlay" id="positionDisplay">X: 0 Y: 0</div>
                        <div class="canvas-fps" id="fpsDisplay">0 FPS</div>
                    </div>

                    <div class="controls">
                        <button class="btn btn-start" id="startBtn">‚ñ∂ START</button>
                        <button class="btn btn-stop" id="stopBtn" disabled>‚èπ STOP</button>
                        <button class="btn btn-reset" id="resetBtn">‚Ü∫ RESET</button>
                    </div>
                </div>

                <div class="card" style="margin-top: 12px;">
                    <div class="card-title">üìä Signal Quality</div>
                    <div style="display: flex; justify-content: space-between; font-size: 0.8rem;">
                        <span>Samples: <span id="sampleCount">0</span></span>
                        <span>Rate: <span id="sampleRate">0</span>/sec</span>
                    </div>
                    <div class="signal-bar">
                        <div class="signal-fill" id="signalFill" style="width: 0%"></div>
                    </div>
                </div>

                <div class="card" style="margin-top: 12px;">
                    <div class="card-title">üìù Raw Data Stream</div>
                    <div class="raw-data" id="rawData">Waiting for data...</div>
                </div>

                <!-- AI Summary Panel -->
                <div class="card ai-panel" style="margin-top: 12px;">
                    <div class="ai-header">
                        <div class="card-title" style="margin-bottom: 0;">ü§ñ AI Live Analysis (Qwen)</div>
                        <div class="ai-status">
                            <span class="ai-status-dot" id="aiStatusDot"></span>
                            <span id="aiStatusText">Disconnected</span>
                        </div>
                    </div>
                    <div style="display: flex; gap: 8px; margin-bottom: 8px; font-size: 0.75rem;">
                        <span style="color: #94a3b8;">Model:</span>
                        <select class="model-select" id="modelSelect">
                            <option value="qwen2.5-coder:7b-instruct-q4_K_M">qwen2.5-coder:7b-instruct</option>
                            <option value="qwen2.5-coder:7b">qwen2.5-coder:7b</option>
                            <option value="jaahas/qwen3-abliterated:8b">qwen3-abliterated:8b</option>
                        </select>
                        <button class="btn" style="flex: 0; padding: 4px 12px; font-size: 0.7rem;"
                            onclick="testOllamaConnection()">Test Connection</button>
                    </div>
                    <div class="ai-summary" id="aiSummary">Start tracking to receive AI analysis of your mouse behavior
                        patterns...</div>
                    <div class="ai-verdict normal" id="aiVerdict" style="display: none;">
                        <span id="aiVerdictText">Normal Movement</span>
                    </div>
                </div>
            </div>

            <!-- Right Panel: Metrics & Charts -->
            <div>
                <!-- Friction Level -->
                <div class="card">
                    <div class="friction-display low" id="frictionDisplay">
                        <div class="friction-level" id="frictionLevel">STABLE</div>
                        <div class="friction-label">Current Friction Level</div>
                    </div>

                    <!-- Primary Metrics -->
                    <div class="metrics-grid">
                        <div class="metric">
                            <div class="metric-value low" id="tremorIndex">0.000</div>
                            <div class="metric-label">TREMOR INDEX</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value low" id="microJitter">0.000</div>
                            <div class="metric-label">MICRO-JITTER</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value low" id="velocityVar">0.000</div>
                            <div class="metric-label">VELOCITY VAR</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value low" id="acceleration">0.000</div>
                            <div class="metric-label">ACCELERATION</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value low" id="directionChanges">0</div>
                            <div class="metric-label">DIR CHANGES</div>
                        </div>
                        <div class="metric">
                            <div class="metric-value low" id="hesitationCount">0</div>
                            <div class="metric-label">HESITATIONS</div>
                        </div>
                    </div>

                    <!-- Advanced Metrics -->
                    <div class="card-title" style="margin-top: 12px;">üîç Advanced Analysis</div>
                    <div class="advanced-metrics">
                        <div class="adv-metric">
                            <span class="adv-metric-label">Smoothness Score</span>
                            <span class="adv-metric-value" id="smoothness">1.000</span>
                        </div>
                        <div class="adv-metric">
                            <span class="adv-metric-label">Curvature Index</span>
                            <span class="adv-metric-value" id="curvature">0.000</span>
                        </div>
                        <div class="adv-metric">
                            <span class="adv-metric-label">Path Efficiency</span>
                            <span class="adv-metric-value" id="pathEfficiency">100%</span>
                        </div>
                        <div class="adv-metric">
                            <span class="adv-metric-label">Micro-Pauses</span>
                            <span class="adv-metric-value" id="microPauses">0</span>
                        </div>
                        <div class="adv-metric">
                            <span class="adv-metric-label">Avg Velocity</span>
                            <span class="adv-metric-value" id="avgVelocity">0 px/s</span>
                        </div>
                        <div class="adv-metric">
                            <span class="adv-metric-label">Peak Velocity</span>
                            <span class="adv-metric-value" id="peakVelocity">0 px/s</span>
                        </div>
                    </div>
                </div>

                <!-- Charts -->
                <div class="charts-grid" style="margin-top: 12px;">
                    <div class="card">
                        <div class="card-title">‚ö° Velocity & Acceleration</div>
                        <div class="chart-container">
                            <canvas id="velocityChart"></canvas>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card-title">üìà Tremor Analysis</div>
                        <div class="chart-container">
                            <canvas id="tremorChart"></canvas>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card-title">üéØ Movement Path</div>
                        <div class="chart-container">
                            <canvas id="pathChart"></canvas>
                        </div>
                    </div>
                    <div class="card">
                        <div class="card-title">üîÑ Direction Changes</div>
                        <div class="chart-container">
                            <canvas id="directionChart"></canvas>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // ============================================
        // ADVANCED MOUSE TRACKER v2 - HIGH PRECISION
        // Uses requestAnimationFrame for 60 FPS sampling
        // ============================================

        class AdvancedMouseTracker {
            constructor(canvas) {
                this.canvas = canvas;
                this.ctx = canvas.getContext('2d');
                this.isTracking = false;

                // High-precision data storage
                this.samples = [];           // All raw samples
                this.velocities = [];        // Velocity history
                this.accelerations = [];     // Acceleration history
                this.directions = [];        // Direction angles
                this.tremorValues = [];      // Micro-tremor measurements

                // Current state
                this.currentPos = { x: 0, y: 0 };
                this.lastPos = null;
                this.lastTime = null;
                this.lastVelocity = 0;

                // Metrics
                this.metrics = {
                    tremorIndex: 0,
                    microJitter: 0,
                    velocityVariance: 0,
                    avgAcceleration: 0,
                    directionChanges: 0,
                    hesitationCount: 0,
                    smoothness: 1,
                    curvature: 0,
                    pathEfficiency: 1,
                    microPauses: 0,
                    avgVelocity: 0,
                    peakVelocity: 0,
                };

                // Timing
                this.startTime = null;
                this.frameCount = 0;
                this.lastFpsUpdate = 0;
                this.fps = 0;

                // Tremor detection window
                this.tremorWindow = [];
                this.TREMOR_WINDOW_SIZE = 10;  // 10 samples for micro-tremor analysis

                // Hesitation detection
                this.hesitationThreshold = 50; // ms without significant movement
                this.lastSignificantMove = 0;

                // Smoothing for visualization
                this.trailPoints = [];
                this.MAX_TRAIL = 200;

                this.animationId = null;

                this.setupEvents();
            }

            setupEvents() {
                this.canvas.addEventListener('mousemove', (e) => {
                    const rect = this.canvas.getBoundingClientRect();
                    this.currentPos = {
                        x: (e.clientX - rect.left) * (this.canvas.width / rect.width),
                        y: (e.clientY - rect.top) * (this.canvas.height / rect.height)
                    };
                });

                this.canvas.addEventListener('mouseleave', () => {
                    this.lastPos = null; // Reset to avoid jumps
                });
            }

            start() {
                this.isTracking = true;
                this.startTime = performance.now();
                this.frameCount = 0;
                this.reset();
                this.track();
            }

            stop() {
                this.isTracking = false;
                if (this.animationId) {
                    cancelAnimationFrame(this.animationId);
                }
            }

            reset() {
                this.samples = [];
                this.velocities = [];
                this.accelerations = [];
                this.directions = [];
                this.tremorValues = [];
                this.tremorWindow = [];
                this.trailPoints = [];
                this.lastPos = null;
                this.lastTime = null;
                this.lastVelocity = 0;
                this.hesitationCount = 0;
                this.microPauses = 0;

                Object.keys(this.metrics).forEach(k => {
                    this.metrics[k] = k === 'smoothness' || k === 'pathEfficiency' ? 1 : 0;
                });

                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
            }

            track() {
                if (!this.isTracking) return;

                const now = performance.now();
                this.frameCount++;

                // Calculate FPS every second
                if (now - this.lastFpsUpdate > 1000) {
                    this.fps = Math.round(this.frameCount / ((now - this.startTime) / 1000));
                    this.lastFpsUpdate = now;
                }

                // Sample current position with high precision timestamp
                if (this.lastPos) {
                    const dx = this.currentPos.x - this.lastPos.x;
                    const dy = this.currentPos.y - this.lastPos.y;
                    const dt = now - this.lastTime;

                    if (dt > 0) {
                        // Calculate velocity (pixels per second)
                        const distance = Math.sqrt(dx * dx + dy * dy);
                        const velocity = (distance / dt) * 1000; // Convert to px/sec

                        // Calculate acceleration
                        const acceleration = (velocity - this.lastVelocity) / dt * 1000;

                        // Calculate direction
                        const direction = Math.atan2(dy, dx);

                        // Store sample
                        const sample = {
                            x: this.currentPos.x,
                            y: this.currentPos.y,
                            t: now,
                            dx, dy, dt,
                            velocity,
                            acceleration,
                            direction,
                            distance
                        };

                        this.samples.push(sample);
                        this.velocities.push(velocity);
                        this.accelerations.push(acceleration);
                        this.directions.push(direction);

                        // Micro-tremor detection (analyze small movements)
                        this.detectMicroTremor(sample);

                        // Hesitation detection
                        if (distance < 2) {
                            if (now - this.lastSignificantMove > this.hesitationThreshold) {
                                this.metrics.microPauses++;
                            }
                        } else {
                            this.lastSignificantMove = now;
                        }

                        // Direction change detection
                        this.detectDirectionChanges();

                        // Update visualization trail
                        this.trailPoints.push({ ...this.currentPos, v: velocity });
                        if (this.trailPoints.length > this.MAX_TRAIL) {
                            this.trailPoints.shift();
                        }

                        this.lastVelocity = velocity;
                    }
                }

                this.lastPos = { ...this.currentPos };
                this.lastTime = now;

                // Update metrics every 5 frames
                if (this.frameCount % 5 === 0) {
                    this.calculateMetrics();
                }

                // Render
                this.render();

                this.animationId = requestAnimationFrame(() => this.track());
            }

            detectMicroTremor(sample) {
                // Use a sliding window for tremor analysis
                this.tremorWindow.push(sample);
                if (this.tremorWindow.length > this.TREMOR_WINDOW_SIZE) {
                    this.tremorWindow.shift();
                }

                if (this.tremorWindow.length >= 3) {
                    // Calculate micro-movements variance
                    const microMovements = this.tremorWindow.map(s => s.distance);
                    const avgMove = microMovements.reduce((a, b) => a + b, 0) / microMovements.length;

                    // Tremor = high variance in small movements
                    const variance = microMovements
                        .map(m => Math.pow(m - avgMove, 2))
                        .reduce((a, b) => a + b, 0) / microMovements.length;

                    // Direction oscillation (back-and-forth)
                    let dirOscillation = 0;
                    for (let i = 2; i < this.tremorWindow.length; i++) {
                        const dir1 = this.tremorWindow[i - 1].direction - this.tremorWindow[i - 2].direction;
                        const dir2 = this.tremorWindow[i].direction - this.tremorWindow[i - 1].direction;
                        // Check if direction reversed
                        if (Math.sign(dir1) !== Math.sign(dir2) && Math.abs(dir1) > 0.1) {
                            dirOscillation++;
                        }
                    }

                    const tremorValue = (Math.sqrt(variance) * 0.5) + (dirOscillation * 0.1);
                    this.tremorValues.push(tremorValue);
                }
            }

            detectDirectionChanges() {
                if (this.directions.length < 3) return;

                const recent = this.directions.slice(-3);
                const change1 = this.normalizeAngle(recent[1] - recent[0]);
                const change2 = this.normalizeAngle(recent[2] - recent[1]);

                // Significant direction change (> 45 degrees)
                if (Math.abs(change2) > Math.PI / 4 && Math.sign(change1) !== Math.sign(change2)) {
                    this.metrics.directionChanges++;
                }
            }

            normalizeAngle(angle) {
                while (angle > Math.PI) angle -= 2 * Math.PI;
                while (angle < -Math.PI) angle += 2 * Math.PI;
                return angle;
            }

            calculateMetrics() {
                if (this.velocities.length < 10) return;

                const recent = this.velocities.slice(-100);
                const recentAcc = this.accelerations.slice(-100);
                const recentTremor = this.tremorValues.slice(-50);

                // Average velocity
                this.metrics.avgVelocity = recent.reduce((a, b) => a + b, 0) / recent.length;
                this.metrics.peakVelocity = Math.max(...recent);

                // Velocity variance (normalized)
                const avgV = this.metrics.avgVelocity;
                const velVariance = recent.map(v => Math.pow(v - avgV, 2)).reduce((a, b) => a + b, 0) / recent.length;
                this.metrics.velocityVariance = Math.min(Math.sqrt(velVariance) / 500, 1);

                // Average acceleration magnitude
                const absAcc = recentAcc.map(Math.abs);
                this.metrics.avgAcceleration = Math.min(absAcc.reduce((a, b) => a + b, 0) / absAcc.length / 10000, 1);

                // Tremor index (average of recent tremor values)
                if (recentTremor.length > 0) {
                    this.metrics.tremorIndex = Math.min(
                        recentTremor.reduce((a, b) => a + b, 0) / recentTremor.length,
                        1
                    );
                }

                // Micro-jitter (high-frequency direction oscillation)
                this.metrics.microJitter = Math.min(this.metrics.directionChanges / Math.max(this.samples.length / 10, 1), 1);

                // Smoothness (inverse of acceleration variance)
                if (absAcc.length > 5) {
                    const accAvg = absAcc.reduce((a, b) => a + b, 0) / absAcc.length;
                    const accVar = absAcc.map(a => Math.pow(a - accAvg, 2)).reduce((a, b) => a + b, 0) / absAcc.length;
                    this.metrics.smoothness = Math.max(1 - Math.sqrt(accVar) / 5000, 0);
                }

                // Curvature (average direction change)
                if (this.directions.length > 10) {
                    const recentDirs = this.directions.slice(-50);
                    let totalCurvature = 0;
                    for (let i = 1; i < recentDirs.length; i++) {
                        totalCurvature += Math.abs(this.normalizeAngle(recentDirs[i] - recentDirs[i - 1]));
                    }
                    this.metrics.curvature = Math.min(totalCurvature / recentDirs.length * 2, 1);
                }

                // Path efficiency (straight line distance / actual path distance)
                if (this.samples.length > 10) {
                    const first = this.samples[0];
                    const last = this.samples[this.samples.length - 1];
                    const straightDist = Math.sqrt(
                        Math.pow(last.x - first.x, 2) + Math.pow(last.y - first.y, 2)
                    );
                    const actualDist = this.samples.reduce((sum, s) => sum + s.distance, 0);
                    this.metrics.pathEfficiency = actualDist > 0 ? Math.min(straightDist / actualDist, 1) : 1;
                }

                this.metrics.microPauses = this.microPauses;
                this.metrics.hesitationCount = Math.floor(this.microPauses / 10);
            }

            getFrictionLevel() {
                const score = (
                    this.metrics.tremorIndex * 0.3 +
                    this.metrics.microJitter * 0.25 +
                    this.metrics.velocityVariance * 0.2 +
                    this.metrics.avgAcceleration * 0.15 +
                    (1 - this.metrics.smoothness) * 0.1
                );

                if (score < 0.15) return { level: 'STABLE', class: 'low' };
                if (score < 0.35) return { level: 'MODERATE', class: 'medium' };
                return { level: 'ELEVATED', class: 'high' };
            }

            render() {
                const ctx = this.ctx;

                // Clear with fade effect
                ctx.fillStyle = 'rgba(0, 0, 0, 0.1)';
                ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);

                // Draw grid
                ctx.strokeStyle = 'rgba(71, 85, 105, 0.2)';
                ctx.lineWidth = 0.5;
                for (let x = 0; x < this.canvas.width; x += 40) {
                    ctx.beginPath();
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, this.canvas.height);
                    ctx.stroke();
                }
                for (let y = 0; y < this.canvas.height; y += 40) {
                    ctx.beginPath();
                    ctx.moveTo(0, y);
                    ctx.lineTo(this.canvas.width, y);
                    ctx.stroke();
                }

                // Draw trail with velocity color coding
                if (this.trailPoints.length > 1) {
                    for (let i = 1; i < this.trailPoints.length; i++) {
                        const p1 = this.trailPoints[i - 1];
                        const p2 = this.trailPoints[i];

                        // Color based on velocity
                        const velocityNorm = Math.min(p2.v / 1000, 1);
                        const hue = 180 - velocityNorm * 120; // Cyan to Red

                        ctx.beginPath();
                        ctx.strokeStyle = `hsla(${hue}, 80%, 60%, ${0.3 + (i / this.trailPoints.length) * 0.7})`;
                        ctx.lineWidth = 2;
                        ctx.moveTo(p1.x, p1.y);
                        ctx.lineTo(p2.x, p2.y);
                        ctx.stroke();
                    }
                }

                // Draw current position
                ctx.beginPath();
                ctx.arc(this.currentPos.x, this.currentPos.y, 6, 0, Math.PI * 2);
                ctx.fillStyle = '#fff';
                ctx.fill();

                // Draw tremor indicator ring
                const tremorSize = 10 + this.metrics.tremorIndex * 30;
                ctx.beginPath();
                ctx.arc(this.currentPos.x, this.currentPos.y, tremorSize, 0, Math.PI * 2);
                ctx.strokeStyle = `rgba(239, 68, 68, ${this.metrics.tremorIndex})`;
                ctx.lineWidth = 2;
                ctx.stroke();
            }

            getData() {
                return {
                    samples: this.samples,
                    metrics: this.metrics,
                    friction: this.getFrictionLevel(),
                    fps: this.fps,
                    duration: (performance.now() - this.startTime) / 1000
                };
            }
        }

        // ============================================
        // CHART SETUP
        // ============================================

        const chartOptions = {
            responsive: true,
            maintainAspectRatio: false,
            animation: { duration: 0 },
            scales: {
                x: { display: false },
                y: { beginAtZero: true, grid: { color: 'rgba(71, 85, 105, 0.3)' }, ticks: { color: '#64748b', font: { size: 9 } } }
            },
            plugins: { legend: { display: false } }
        };

        const velocityChart = new Chart(document.getElementById('velocityChart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    { label: 'Velocity', data: [], borderColor: '#06b6d4', borderWidth: 1.5, fill: false, tension: 0.2, pointRadius: 0 },
                    { label: 'Acceleration', data: [], borderColor: '#f59e0b', borderWidth: 1.5, fill: false, tension: 0.2, pointRadius: 0 }
                ]
            },
            options: chartOptions
        });

        const tremorChart = new Chart(document.getElementById('tremorChart'), {
            type: 'line',
            data: {
                labels: [],
                datasets: [
                    { label: 'Tremor', data: [], borderColor: '#ef4444', backgroundColor: 'rgba(239, 68, 68, 0.1)', fill: true, tension: 0.3, pointRadius: 0 }
                ]
            },
            options: chartOptions
        });

        const pathChart = new Chart(document.getElementById('pathChart'), {
            type: 'scatter',
            data: { datasets: [{ label: 'Path', data: [], backgroundColor: 'rgba(139, 92, 246, 0.5)', pointRadius: 2 }] },
            options: { ...chartOptions, scales: { x: { display: true }, y: { display: true } } }
        });

        const directionChart = new Chart(document.getElementById('directionChart'), {
            type: 'bar',
            data: {
                labels: ['N', 'NE', 'E', 'SE', 'S', 'SW', 'W', 'NW'],
                datasets: [{ label: 'Direction', data: [0, 0, 0, 0, 0, 0, 0, 0], backgroundColor: 'rgba(16, 185, 129, 0.6)' }]
            },
            options: chartOptions
        });

        // ============================================
        // OLLAMA AI INTEGRATION
        // ============================================

        const OLLAMA_URL = 'http://localhost:11434';
        let aiAnalysisInterval = null;
        let isAiConnected = false;
        let lastAiAnalysis = '';

        async function testOllamaConnection() {
            const statusDot = document.getElementById('aiStatusDot');
            const statusText = document.getElementById('aiStatusText');
            const aiSummary = document.getElementById('aiSummary');

            statusDot.className = 'ai-status-dot thinking';
            statusText.textContent = 'Connecting...';

            try {
                const response = await fetch(`${OLLAMA_URL}/api/tags`);
                if (response.ok) {
                    const data = await response.json();
                    isAiConnected = true;
                    statusDot.className = 'ai-status-dot connected';
                    statusText.textContent = 'Connected';
                    aiSummary.textContent = `‚úÖ Connected to Ollama! Found ${data.models?.length || 0} models. Start tracking to receive AI analysis.`;
                    aiSummary.className = 'ai-summary';
                } else {
                    throw new Error('Failed to connect');
                }
            } catch (error) {
                isAiConnected = false;
                statusDot.className = 'ai-status-dot error';
                statusText.textContent = 'Error';
                aiSummary.textContent = `‚ùå Cannot connect to Ollama at ${OLLAMA_URL}. Make sure Ollama is running (ollama serve).`;
                aiSummary.className = 'ai-summary';
            }
        }

        async function analyzeWithAI(metrics, frictionLevel) {
            if (!isAiConnected) return;

            const model = document.getElementById('modelSelect').value;
            const statusDot = document.getElementById('aiStatusDot');
            const statusText = document.getElementById('aiStatusText');
            const aiSummary = document.getElementById('aiSummary');
            const aiVerdict = document.getElementById('aiVerdict');
            const aiVerdictText = document.getElementById('aiVerdictText');

            statusDot.className = 'ai-status-dot thinking';
            statusText.textContent = 'Analyzing...';

            const prompt = `You are an AI analyzing mouse movement data for learning friction detection. Analyze these metrics and determine if the mouse movement shows signs of tremor, anxiety, uncertainty, or normal controlled movement.

Current Metrics:
- Tremor Index: ${metrics.tremorIndex.toFixed(3)} (0-1 scale, higher = more tremor)
- Micro-Jitter: ${metrics.microJitter.toFixed(3)} (0-1 scale, higher = more jitter)
- Velocity Variance: ${metrics.velocityVariance.toFixed(3)} (0-1 scale, higher = more erratic)
- Acceleration: ${metrics.avgAcceleration.toFixed(3)} (0-1 scale)
- Direction Changes: ${metrics.directionChanges}
- Smoothness: ${metrics.smoothness.toFixed(3)} (0-1 scale, higher = smoother)
- Curvature: ${metrics.curvature.toFixed(3)} (0-1 scale)
- Path Efficiency: ${(metrics.pathEfficiency * 100).toFixed(1)}%
- Micro-Pauses: ${metrics.microPauses}
- Current Friction Level: ${frictionLevel}

Provide a brief 2-3 sentence analysis. Then on a new line, give your verdict in exactly this format:
VERDICT: [NORMAL/UNCERTAIN/ABNORMAL]

Be concise and focus on whether the movement patterns suggest:
1. Normal controlled movement
2. Signs of uncertainty or hesitation
3. Abnormal tremor or anxiety-like patterns`;

            try {
                const response = await fetch(`${OLLAMA_URL}/api/generate`, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        model: model,
                        prompt: prompt,
                        stream: false,
                        options: {
                            temperature: 0.3,
                            num_predict: 150
                        }
                    })
                });

                if (response.ok) {
                    const data = await response.json();
                    const aiResponse = data.response || 'No response';
                    lastAiAnalysis = aiResponse;

                    // Parse verdict
                    let verdict = 'NORMAL';
                    if (aiResponse.includes('VERDICT: ABNORMAL')) verdict = 'ABNORMAL';
                    else if (aiResponse.includes('VERDICT: UNCERTAIN')) verdict = 'UNCERTAIN';
                    else if (aiResponse.includes('VERDICT: NORMAL')) verdict = 'NORMAL';

                    // Update UI
                    aiSummary.textContent = aiResponse.replace(/VERDICT:.*$/i, '').trim();
                    aiSummary.className = 'ai-summary';

                    aiVerdict.style.display = 'block';
                    aiVerdict.className = `ai-verdict ${verdict.toLowerCase()}`;
                    aiVerdictText.textContent = verdict === 'NORMAL' ? '‚úÖ Normal Movement' :
                        verdict === 'UNCERTAIN' ? '‚ö†Ô∏è Signs of Uncertainty' :
                            'üö® Abnormal Pattern Detected';

                    statusDot.className = 'ai-status-dot connected';
                    statusText.textContent = 'Connected';
                } else {
                    throw new Error('API error');
                }
            } catch (error) {
                console.error('AI analysis error:', error);
                aiSummary.textContent = '‚ö†Ô∏è Error getting AI analysis. Will retry...';
                statusDot.className = 'ai-status-dot error';
                statusText.textContent = 'Error';
            }
        }

        function startAiAnalysis() {
            // Run AI analysis every 5 seconds during tracking
            aiAnalysisInterval = setInterval(() => {
                if (tracker.isTracking && tracker.samples.length > 50) {
                    const data = tracker.getData();
                    analyzeWithAI(data.metrics, data.friction.level);
                }
            }, 5000);
        }

        function stopAiAnalysis() {
            if (aiAnalysisInterval) {
                clearInterval(aiAnalysisInterval);
                aiAnalysisInterval = null;
            }
        }

        // ============================================
        // INITIALIZATION
        // ============================================

        const canvas = document.getElementById('trackingCanvas');
        const tracker = new AdvancedMouseTracker(canvas);

        let updateInterval;

        // Test Ollama connection on page load
        setTimeout(testOllamaConnection, 1000);

        function updateUI() {
            const data = tracker.getData();

            // Update position display
            document.getElementById('positionDisplay').textContent =
                `X: ${Math.round(tracker.currentPos.x)} Y: ${Math.round(tracker.currentPos.y)}`;
            document.getElementById('fpsDisplay').textContent = `${data.fps} FPS`;

            // Update metrics
            document.getElementById('tremorIndex').textContent = data.metrics.tremorIndex.toFixed(3);
            document.getElementById('microJitter').textContent = data.metrics.microJitter.toFixed(3);
            document.getElementById('velocityVar').textContent = data.metrics.velocityVariance.toFixed(3);
            document.getElementById('acceleration').textContent = data.metrics.avgAcceleration.toFixed(3);
            document.getElementById('directionChanges').textContent = data.metrics.directionChanges;
            document.getElementById('hesitationCount').textContent = data.metrics.hesitationCount;

            document.getElementById('smoothness').textContent = data.metrics.smoothness.toFixed(3);
            document.getElementById('curvature').textContent = data.metrics.curvature.toFixed(3);
            document.getElementById('pathEfficiency').textContent = (data.metrics.pathEfficiency * 100).toFixed(0) + '%';
            document.getElementById('microPauses').textContent = data.metrics.microPauses;
            document.getElementById('avgVelocity').textContent = Math.round(data.metrics.avgVelocity) + ' px/s';
            document.getElementById('peakVelocity').textContent = Math.round(data.metrics.peakVelocity) + ' px/s';

            // Color code metrics
            ['tremorIndex', 'microJitter', 'velocityVar', 'acceleration'].forEach(id => {
                const el = document.getElementById(id);
                const val = parseFloat(el.textContent);
                el.className = 'metric-value ' + (val < 0.2 ? 'low' : val < 0.5 ? 'medium' : 'high');
            });

            // Update friction display
            const frictionDisplay = document.getElementById('frictionDisplay');
            const frictionLevel = document.getElementById('frictionLevel');
            frictionDisplay.className = `friction-display ${data.friction.class}`;
            frictionLevel.textContent = data.friction.level;

            // Update signal quality
            document.getElementById('sampleCount').textContent = data.samples.length;
            document.getElementById('sampleRate').textContent = Math.round(data.samples.length / Math.max(data.duration, 1));
            document.getElementById('signalFill').style.width = Math.min(data.fps / 60 * 100, 100) + '%';

            // Update raw data
            if (data.samples.length > 0) {
                const latest = data.samples.slice(-5).reverse();
                document.getElementById('rawData').innerHTML = latest.map(s =>
                    `t:${s.t.toFixed(0)} x:${s.x.toFixed(1)} y:${s.y.toFixed(1)} v:${s.velocity.toFixed(1)} a:${s.acceleration.toFixed(1)}`
                ).join('<br>');
            }

            // Update charts
            const len = Math.min(data.samples.length, 100);
            const labels = Array(len).fill('');

            velocityChart.data.labels = labels;
            velocityChart.data.datasets[0].data = tracker.velocities.slice(-100);
            velocityChart.data.datasets[1].data = tracker.accelerations.slice(-100).map(a => Math.abs(a) / 100);
            velocityChart.update('none');

            tremorChart.data.labels = labels;
            tremorChart.data.datasets[0].data = tracker.tremorValues.slice(-100);
            tremorChart.update('none');

            pathChart.data.datasets[0].data = data.samples.slice(-200).map(s => ({ x: s.x, y: s.y }));
            pathChart.update('none');

            // Direction histogram
            const dirBins = [0, 0, 0, 0, 0, 0, 0, 0];
            tracker.directions.forEach(d => {
                const bin = Math.floor(((d + Math.PI) / (2 * Math.PI)) * 8) % 8;
                dirBins[bin]++;
            });
            directionChart.data.datasets[0].data = dirBins;
            directionChart.update('none');
        }

        document.getElementById('startBtn').addEventListener('click', () => {
            tracker.start();
            document.getElementById('startBtn').disabled = true;
            document.getElementById('stopBtn').disabled = false;
            updateInterval = setInterval(updateUI, 100);
            startAiAnalysis();
            document.getElementById('aiSummary').textContent = 'üîÑ Collecting data... AI analysis will begin shortly.';
            document.getElementById('aiSummary').className = 'ai-summary loading';
            document.getElementById('aiVerdict').style.display = 'none';
        });

        document.getElementById('stopBtn').addEventListener('click', () => {
            tracker.stop();
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            clearInterval(updateInterval);
            stopAiAnalysis();
            updateUI();
            // Run final AI analysis
            if (tracker.samples.length > 10) {
                const data = tracker.getData();
                analyzeWithAI(data.metrics, data.friction.level);
            }
        });

        document.getElementById('resetBtn').addEventListener('click', () => {
            tracker.stop();
            tracker.reset();
            document.getElementById('startBtn').disabled = false;
            document.getElementById('stopBtn').disabled = true;
            clearInterval(updateInterval);

            // Reset UI
            document.getElementById('tremorIndex').textContent = '0.000';
            document.getElementById('microJitter').textContent = '0.000';
            document.getElementById('velocityVar').textContent = '0.000';
            document.getElementById('acceleration').textContent = '0.000';
            document.getElementById('directionChanges').textContent = '0';
            document.getElementById('hesitationCount').textContent = '0';
            document.getElementById('frictionLevel').textContent = 'STABLE';
            document.getElementById('frictionDisplay').className = 'friction-display low';
            document.getElementById('rawData').textContent = 'Waiting for data...';

            velocityChart.data.datasets[0].data = [];
            velocityChart.data.datasets[1].data = [];
            velocityChart.update();
            tremorChart.data.datasets[0].data = [];
            tremorChart.update();
            pathChart.data.datasets[0].data = [];
            pathChart.update();
            directionChart.data.datasets[0].data = [0, 0, 0, 0, 0, 0, 0, 0];
            directionChart.update();
        });
    </script>
</body>

</html>